<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Picture Filter</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }

  #toolbar {
    display: flex; align-items: center; gap: 12px; padding: 8px 16px;
    background: #16213e; border-bottom: 1px solid #0f3460; flex-shrink: 0; flex-wrap: wrap;
  }
  #toolbar label { font-size: 13px; }
  #toolbar input[type="file"] { font-size: 13px; }
  #toolbar .sep { width: 1px; height: 24px; background: #0f3460; }
  #toolbar button {
    padding: 4px 12px; border: 1px solid #0f3460; background: #1a1a2e; color: #eee;
    border-radius: 4px; cursor: pointer; font-size: 13px;
  }
  #toolbar button.active { background: #e94560; border-color: #e94560; }
  #toolbar button:hover { background: #0f3460; }
  #toolbar button.active:hover { background: #c73e54; }
  #toolbar select, #toolbar input[type="color"] { font-size: 13px; padding: 2px 4px; }
  #toolbar .tool-group { display: flex; align-items: center; gap: 6px; }

  #grid {
    flex: 1; display: grid; grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr; gap: 2px; background: #0a0a1a; overflow: hidden;
  }

  .panel {
    position: relative; overflow: hidden; background: #16213e;
  }
  .panel-header {
    position: absolute; top: 0; left: 0; right: 0; z-index: 10;
    background: rgba(22,33,62,0.9); padding: 4px 8px; font-size: 12px;
    display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
  }
  .panel-header .title { font-weight: bold; font-size: 13px; }
  .panel-header label { font-size: 11px; white-space: nowrap; }
  .panel-header .val { display: inline-block; min-width: 2.2em; text-align: right; }
  .panel-header input[type="range"] { width: 80px; vertical-align: middle; }
  .panel-header select { font-size: 11px; padding: 1px 2px; }
  .panel canvas {
    position: absolute; top: 0; left: 0;
  }

  #drop-overlay {
    display: none; position: fixed; inset: 0; z-index: 100;
    background: rgba(233,69,96,0.15); border: 3px dashed #e94560;
    justify-content: center; align-items: center; font-size: 24px;
  }
  #drop-overlay.visible { display: flex; }

  #cv-status {
    position: fixed; bottom: 8px; right: 12px; z-index: 50;
    font-size: 11px; padding: 3px 8px; border-radius: 4px;
    background: rgba(22,33,62,0.9); border: 1px solid #0f3460;
  }
  #cv-status.ready { color: #4ade80; }
  #cv-status.loading { color: #facc15; }
  #cv-status.error { color: #f87171; }
</style>
</head>
<body>

<div id="toolbar">
  <input type="file" id="fileInput" accept="image/*">
  <div class="sep"></div>
  <div class="tool-group">
    <label>Tool:</label>
    <button id="btnPan" class="active" data-tool="pan">Pan</button>
    <button id="btnZoom" data-tool="zoom">Zoom</button>
    <button id="btnLine" data-tool="line">Line</button>
    <button id="btnFree" data-tool="free">Freehand</button>
  </div>
  <div class="sep"></div>
  <div class="tool-group">
    <label>Color:</label>
    <input type="color" id="annotColor" value="#ff0000">
    <label>Width:</label>
    <select id="annotWidth">
      <option value="1">1px</option>
      <option value="2" selected>2px</option>
      <option value="3">3px</option>
      <option value="5">5px</option>
      <option value="8">8px</option>
    </select>
  </div>
  <div class="sep"></div>
  <button id="btnUndo">Undo</button>
  <button id="btnClearAnnot">Clear Annotations</button>
  <div class="sep"></div>
  <button id="btnResetView">Reset View</button>
</div>

<div id="grid">
  <div class="panel" id="p0">
    <div class="panel-header"><span class="title">Original</span></div>
    <canvas></canvas>
  </div>
  <div class="panel" id="p1">
    <div class="panel-header"><span class="title">Grayscale</span></div>
    <canvas></canvas>
  </div>
  <div class="panel" id="p2">
    <div class="panel-header">
      <span class="title">Binary</span>
      <label>Threshold: <span id="binVal" class="val">128</span></label>
      <input type="range" id="binThresh" min="0" max="255" value="128">
    </div>
    <canvas></canvas>
  </div>
  <div class="panel" id="p3">
    <div class="panel-header">
      <span class="title">Edge</span>
      <label>Threshold: <span id="edgeVal" class="val">30</span></label>
      <input type="range" id="edgeThresh" min="0" max="255" value="30">
    </div>
    <canvas></canvas>
  </div>
  <div class="panel" id="p4">
    <div class="panel-header">
      <span class="title">Blur</span>
      <label>Type:</label>
      <select id="blurType">
        <option value="box">Box</option>
        <option value="gaussian" selected>Gaussian</option>
        <option value="median">Median</option>
        <option value="bilateral">Bilateral</option>
      </select>
      <label>Radius: <span id="blurRadiusVal" class="val">3</span></label>
      <input type="range" id="blurRadius" min="1" max="20" value="3">
    </div>
    <canvas></canvas>
  </div>
  <div class="panel" id="p5">
    <div class="panel-header">
      <span class="title">Reduce Color</span>
      <label>Colors: <span id="reduceColorsVal" class="val">8</span></label>
      <input type="range" id="reduceColors" min="2" max="32" value="8">
    </div>
    <canvas></canvas>
  </div>
</div>

<div id="drop-overlay">Drop image here</div>
<div id="cv-status" class="loading">OpenCV.js loading...</div>
<div style="position:fixed;bottom:8px;left:12px;font-size:10px;color:#555;">Powered by <a href="https://github.com/opencv/opencv" target="_blank" style="color:#668;">OpenCV.js</a> (Apache 2.0)</div>

<script>
// ---- OpenCV.js loading ----
let cvReady = false;
(function loadOpenCV() {
  const script = document.createElement('script');
  script.async = true;
  script.src = 'opencv.js';
  script.onload = () => {
    if (typeof cv !== 'undefined') {
      if (cv.Mat) {
        onCvReady();
      } else {
        cv['onRuntimeInitialized'] = onCvReady;
      }
    }
  };
  script.onerror = () => {
    const el = document.getElementById('cv-status');
    el.textContent = 'OpenCV.js failed to load (blur uses JS fallback)';
    el.className = 'error';
  };
  document.head.appendChild(script);
})();
function onCvReady() {
  cvReady = true;
  const el = document.getElementById('cv-status');
  el.textContent = 'OpenCV.js ready';
  el.className = 'ready';
  setTimeout(() => el.style.display = 'none', 2000);
  invalidateFilter(4);
  if (srcImage) scheduleRender();
}

// ---- State ----
let srcImage = null;
const view = { x: 0, y: 0, scale: 1 };
let annotations = []; // {type:'line'|'free', points:[[x,y],...], color, width}
let currentTool = 'pan';
let drawState = null; // in-progress annotation

const panels = [];
const canvases = [];
const PANEL_COUNT = 6;

// ---- Working resolution system ----
// Filters run at a resolution matched to the current zoom level, not full image size.
let workingCanvas = null; // source image downsampled to current mip level
let workingGray = null;   // grayscale Uint8Array at working resolution
let workingMip = -1;      // current mip level (1 = full res, 0.5 = half, etc.)

// Per-panel filter cache (persists across frames, invalidated explicitly)
const filterResults = new Array(PANEL_COUNT).fill(null);
const filterCacheKeys = new Array(PANEL_COUNT).fill('');

// ---- Init ----
for (let i = 0; i < PANEL_COUNT; i++) {
  const panel = document.getElementById('p' + i);
  const canvas = panel.querySelector('canvas');
  panels.push(panel);
  canvases.push(canvas);
}

function resizeCanvases() {
  for (let i = 0; i < PANEL_COUNT; i++) {
    const rect = panels[i].getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvases[i].width = rect.width * dpr;
    canvases[i].height = rect.height * dpr;
    canvases[i].style.width = rect.width + 'px';
    canvases[i].style.height = rect.height + 'px';
  }
  renderAll();
}
window.addEventListener('resize', resizeCanvases);

// ---- File loading ----
document.getElementById('fileInput').addEventListener('change', e => {
  if (e.target.files[0]) loadFile(e.target.files[0]);
});

// Drag & drop
document.addEventListener('dragover', e => { e.preventDefault(); document.getElementById('drop-overlay').classList.add('visible'); });
document.addEventListener('dragleave', e => { if (e.relatedTarget === null) document.getElementById('drop-overlay').classList.remove('visible'); });
document.addEventListener('drop', e => {
  e.preventDefault();
  document.getElementById('drop-overlay').classList.remove('visible');
  if (e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
});

function loadFile(file) {
  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => {
      srcImage = img;
      workingMip = -1; // force recompute
      invalidateAllFilters();
      resetView();
      renderAll();
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
}

function resetView() {
  if (!srcImage) return;
  const rect = panels[0].getBoundingClientRect();
  const sx = rect.width / srcImage.width;
  const sy = rect.height / srcImage.height;
  view.scale = Math.min(sx, sy) * 0.9;
  view.x = (rect.width - srcImage.width * view.scale) / 2;
  view.y = (rect.height - srcImage.height * view.scale) / 2;
}

// ---- Working resolution management ----
function computeMipLevel() {
  const dpr = window.devicePixelRatio || 1;
  const eff = view.scale * dpr;
  // Discrete levels to avoid constant recomputation
  if (eff >= 0.5)   return 1;
  if (eff >= 0.25)  return 0.5;
  if (eff >= 0.125) return 0.25;
  return 0.125;
}

function ensureWorkingData() {
  const mip = computeMipLevel();
  if (mip === workingMip && workingCanvas) return;

  workingMip = mip;
  const w = Math.max(1, Math.round(srcImage.width * mip));
  const h = Math.max(1, Math.round(srcImage.height * mip));

  workingCanvas = document.createElement('canvas');
  workingCanvas.width = w;
  workingCanvas.height = h;
  const ctx = workingCanvas.getContext('2d');
  ctx.drawImage(srcImage, 0, 0, w, h);

  // Compute grayscale at working resolution
  const id = ctx.getImageData(0, 0, w, h);
  const d = id.data;
  workingGray = new Uint8Array(w * h);
  for (let i = 0; i < workingGray.length; i++) {
    workingGray[i] = Math.round(0.299 * d[i*4] + 0.587 * d[i*4+1] + 0.114 * d[i*4+2]);
  }

  // Working data changed â†’ all filter caches are stale
  invalidateAllFilters();
}

function invalidateFilter(idx) {
  filterCacheKeys[idx] = '';
  filterResults[idx] = null;
}
function invalidateAllFilters() {
  for (let i = 0; i < PANEL_COUNT; i++) invalidateFilter(i);
}

// ---- Rendering ----
let renderRAF = null;

function scheduleRender() {
  if (!renderRAF) renderRAF = requestAnimationFrame(() => { renderRAF = null; renderAll(); });
}

/** Full render: recompute working data & filters if needed, then draw. */
function renderAll() {
  if (!srcImage) return;
  ensureWorkingData();
  for (let i = 0; i < PANEL_COUNT; i++) {
    ensureFilter(i);
    drawPanel(i);
  }
}

/** Fast redraw: use cached filter results, just redraw canvases. For pan/annotation. */
function renderView() {
  if (!srcImage) return;
  for (let i = 0; i < PANEL_COUNT; i++) drawPanel(i);
}

function ensureFilter(idx) {
  if (idx === 0) return; // original panel has no filter
  const key = idx + '_' + getFilterKey(idx) + '_' + workingMip;
  if (filterCacheKeys[idx] === key && filterResults[idx]) return;
  filterResults[idx] = computeFilter(idx);
  filterCacheKeys[idx] = key;
}

function drawPanel(idx) {
  const canvas = canvases[idx];
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  const rect = panels[idx].getBoundingClientRect();
  ctx.clearRect(0, 0, rect.width, rect.height);

  ctx.save();
  ctx.translate(view.x, view.y);
  ctx.scale(view.scale, view.scale);

  // Draw the image scaled to original image dimensions
  // (workingCanvas / filterResults are at mip resolution; drawImage stretches them)
  const imgToDraw = idx === 0 ? (workingCanvas || null) : filterResults[idx];
  if (imgToDraw) {
    ctx.imageSmoothingEnabled = (view.scale * workingMip) < 2;
    ctx.drawImage(imgToDraw, 0, 0, srcImage.width, srcImage.height);
  }

  // Draw annotations (in image coordinate space)
  for (const a of annotations) drawAnnotation(ctx, a);
  if (drawState) drawAnnotation(ctx, drawState);

  ctx.restore();
}

function drawAnnotation(ctx, a) {
  if (a.points.length < 1) return;
  ctx.strokeStyle = a.color;
  ctx.lineWidth = a.width / view.scale;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  ctx.moveTo(a.points[0][0], a.points[0][1]);
  if (a.type === 'line' && a.points.length === 2) {
    ctx.lineTo(a.points[1][0], a.points[1][1]);
  } else {
    for (let i = 1; i < a.points.length; i++) ctx.lineTo(a.points[i][0], a.points[i][1]);
  }
  ctx.stroke();
}

// ---- Filter computation (at working resolution) ----
function computeFilter(idx) {
  const w = workingCanvas.width, h = workingCanvas.height;
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');

  if (idx === 1) {
    // Grayscale
    const id = ctx.createImageData(w, h);
    const d = id.data;
    for (let i = 0; i < workingGray.length; i++) {
      const v = workingGray[i];
      d[i*4] = v; d[i*4+1] = v; d[i*4+2] = v; d[i*4+3] = 255;
    }
    ctx.putImageData(id, 0, 0);
  } else if (idx === 2) {
    // Binary
    const thresh = parseInt(document.getElementById('binThresh').value);
    const id = ctx.createImageData(w, h);
    const d = id.data;
    for (let i = 0; i < workingGray.length; i++) {
      const v = workingGray[i] >= thresh ? 255 : 0;
      d[i*4] = v; d[i*4+1] = v; d[i*4+2] = v; d[i*4+3] = 255;
    }
    ctx.putImageData(id, 0, 0);
  } else if (idx === 3) {
    // Edge (Sobel)
    const thresh = parseInt(document.getElementById('edgeThresh').value);
    const id = ctx.createImageData(w, h);
    const d = id.data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let gx = 0, gy = 0;
        if (x > 0 && x < w-1 && y > 0 && y < h-1) {
          const g = (ox, oy) => workingGray[(y+oy)*w + (x+ox)];
          gx = -g(-1,-1) + g(1,-1) - 2*g(-1,0) + 2*g(1,0) - g(-1,1) + g(1,1);
          gy = -g(-1,-1) - 2*g(0,-1) - g(1,-1) + g(-1,1) + 2*g(0,1) + g(1,1);
        }
        const mag = Math.sqrt(gx*gx + gy*gy);
        const v = mag > thresh ? Math.min(255, Math.round(mag)) : 0;
        const pi = (y*w + x)*4;
        d[pi] = v; d[pi+1] = v; d[pi+2] = v; d[pi+3] = 255;
      }
    }
    ctx.putImageData(id, 0, 0);
  } else if (idx === 4) {
    // Blur
    const type = document.getElementById('blurType').value;
    const radius = parseInt(document.getElementById('blurRadius').value);
    ctx.drawImage(workingCanvas, 0, 0);
    applyBlur(ctx, w, h, radius, type);
  } else if (idx === 5) {
    // Reduce Color (k-means)
    const k = parseInt(document.getElementById('reduceColors').value);
    return applyReduceColor(w, h, k);
  }

  return c;
}

function getFilterKey(idx) {
  if (idx === 2) return document.getElementById('binThresh').value;
  if (idx === 3) return document.getElementById('edgeThresh').value;
  if (idx === 4) return document.getElementById('blurType').value + '_' + document.getElementById('blurRadius').value;
  if (idx === 5) return document.getElementById('reduceColors').value;
  return '';
}

// ---- Blur (OpenCV.js with JS fallback) ----
function applyBlur(ctx, w, h, radius, type) {
  if (cvReady) {
    applyBlurCV(ctx, w, h, radius, type);
  } else {
    applyBlurFallback(ctx, w, h, radius);
  }
}

function applyBlurCV(ctx, w, h, radius, type) {
  const imgData = ctx.getImageData(0, 0, w, h);
  const src = cv.matFromImageData(imgData);
  const dst = new cv.Mat();
  const ksize = radius * 2 + 1;

  try {
    if (type === 'box') {
      cv.blur(src, dst, new cv.Size(ksize, ksize));
    } else if (type === 'gaussian') {
      cv.GaussianBlur(src, dst, new cv.Size(ksize, ksize), 0);
    } else if (type === 'median') {
      cv.medianBlur(src, dst, ksize);
    } else if (type === 'bilateral') {
      // bilateralFilter requires 1 or 3 channels, not 4
      const src3 = new cv.Mat();
      const dst3 = new cv.Mat();
      cv.cvtColor(src, src3, cv.COLOR_RGBA2RGB);
      cv.bilateralFilter(src3, dst3, ksize, 75, 75);
      cv.cvtColor(dst3, dst, cv.COLOR_RGB2RGBA);
      src3.delete();
      dst3.delete();
    }

    const outData = new ImageData(new Uint8ClampedArray(dst.data), w, h);
    ctx.putImageData(outData, 0, 0);
  } finally {
    src.delete();
    if (!dst.isDeleted()) dst.delete();
  }
}

// Simple JS fallback (Gaussian only) used while OpenCV is loading
function applyBlurFallback(ctx, w, h, radius) {
  const id = ctx.getImageData(0, 0, w, h);
  const src = new Uint8ClampedArray(id.data);
  const dst = id.data;
  const sigma = Math.max(radius / 2.5, 0.5);
  const size = radius * 2 + 1;
  const kernel = new Float32Array(size);
  let sum = 0;
  for (let i = 0; i < size; i++) {
    const x = i - radius;
    kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
    sum += kernel[i];
  }
  for (let i = 0; i < size; i++) kernel[i] /= sum;

  const tmp = new Float32Array(w * h * 4);
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let sr = 0, sg = 0, sb = 0;
      for (let ki = 0; ki < size; ki++) {
        const sx = Math.min(w - 1, Math.max(0, x + ki - radius));
        const i = (y * w + sx) * 4;
        sr += src[i] * kernel[ki]; sg += src[i+1] * kernel[ki]; sb += src[i+2] * kernel[ki];
      }
      const i = (y * w + x) * 4;
      tmp[i] = sr; tmp[i+1] = sg; tmp[i+2] = sb;
    }
  }
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let sr = 0, sg = 0, sb = 0;
      for (let ki = 0; ki < size; ki++) {
        const sy = Math.min(h - 1, Math.max(0, y + ki - radius));
        const i = (sy * w + x) * 4;
        sr += tmp[i] * kernel[ki]; sg += tmp[i+1] * kernel[ki]; sb += tmp[i+2] * kernel[ki];
      }
      const i = (y * w + x) * 4;
      dst[i] = Math.round(sr); dst[i+1] = Math.round(sg); dst[i+2] = Math.round(sb); dst[i+3] = 255;
    }
  }
  ctx.putImageData(id, 0, 0);
}

// ---- Reduce Color (k-means) ----
function applyReduceColor(w, h, k) {
  const n = w * h;
  const srcCtx = workingCanvas.getContext('2d');
  const srcId = srcCtx.getImageData(0, 0, w, h);
  const src = srcId.data;

  // Extract RGB into flat array
  const pixels = new Float32Array(n * 3);
  for (let i = 0; i < n; i++) {
    pixels[i*3] = src[i*4]; pixels[i*3+1] = src[i*4+1]; pixels[i*3+2] = src[i*4+2];
  }

  // Subsample for k-means speed
  const step = Math.max(1, Math.floor(Math.sqrt(n / 5000)));
  const sampleIdx = [];
  for (let i = 0; i < n; i += step) sampleIdx.push(i);
  const sn = sampleIdx.length;

  // K-means++ init (max-distance, deterministic)
  const centroids = new Float32Array(k * 3);
  centroids[0] = pixels[sampleIdx[0]*3];
  centroids[1] = pixels[sampleIdx[0]*3+1];
  centroids[2] = pixels[sampleIdx[0]*3+2];
  const dists = new Float32Array(sn);
  for (let c = 1; c < k; c++) {
    let maxD = -1, maxSi = 0;
    for (let si = 0; si < sn; si++) {
      const pi = sampleIdx[si] * 3;
      const dr = pixels[pi] - centroids[(c-1)*3];
      const dg = pixels[pi+1] - centroids[(c-1)*3+1];
      const db = pixels[pi+2] - centroids[(c-1)*3+2];
      const d = dr*dr + dg*dg + db*db;
      dists[si] = c === 1 ? d : Math.min(dists[si], d);
      if (dists[si] > maxD) { maxD = dists[si]; maxSi = si; }
    }
    const pi = sampleIdx[maxSi] * 3;
    centroids[c*3] = pixels[pi]; centroids[c*3+1] = pixels[pi+1]; centroids[c*3+2] = pixels[pi+2];
  }

  // K-means iterations on subsample
  const sAssign = new Uint16Array(sn);
  for (let iter = 0; iter < 10; iter++) {
    for (let si = 0; si < sn; si++) {
      const pi = sampleIdx[si] * 3;
      let minD = Infinity, minC = 0;
      for (let c = 0; c < k; c++) {
        const dr = pixels[pi] - centroids[c*3];
        const dg = pixels[pi+1] - centroids[c*3+1];
        const db = pixels[pi+2] - centroids[c*3+2];
        const d = dr*dr + dg*dg + db*db;
        if (d < minD) { minD = d; minC = c; }
      }
      sAssign[si] = minC;
    }
    const sums = new Float32Array(k * 3);
    const counts = new Uint32Array(k);
    for (let si = 0; si < sn; si++) {
      const c = sAssign[si];
      const pi = sampleIdx[si] * 3;
      sums[c*3] += pixels[pi]; sums[c*3+1] += pixels[pi+1]; sums[c*3+2] += pixels[pi+2];
      counts[c]++;
    }
    for (let c = 0; c < k; c++) {
      if (counts[c] > 0) {
        centroids[c*3] = sums[c*3]/counts[c];
        centroids[c*3+1] = sums[c*3+1]/counts[c];
        centroids[c*3+2] = sums[c*3+2]/counts[c];
      }
    }
  }

  // Assign all pixels to nearest centroid
  const out = document.createElement('canvas');
  out.width = w; out.height = h;
  const ctx = out.getContext('2d');
  const outId = ctx.createImageData(w, h);
  const d = outId.data;
  for (let i = 0; i < n; i++) {
    const pi = i * 3;
    let minD = Infinity, minC = 0;
    for (let c = 0; c < k; c++) {
      const dr = pixels[pi] - centroids[c*3];
      const dg = pixels[pi+1] - centroids[c*3+1];
      const db = pixels[pi+2] - centroids[c*3+2];
      const dd = dr*dr + dg*dg + db*db;
      if (dd < minD) { minD = dd; minC = c; }
    }
    d[i*4]   = Math.round(centroids[minC*3]);
    d[i*4+1] = Math.round(centroids[minC*3+1]);
    d[i*4+2] = Math.round(centroids[minC*3+2]);
    d[i*4+3] = 255;
  }
  ctx.putImageData(outId, 0, 0);
  return out;
}

// ---- Controls ----
document.getElementById('binThresh').addEventListener('input', e => {
  document.getElementById('binVal').textContent = e.target.value;
  invalidateFilter(2);
  scheduleRender();
});
document.getElementById('edgeThresh').addEventListener('input', e => {
  document.getElementById('edgeVal').textContent = e.target.value;
  invalidateFilter(3);
  scheduleRender();
});
document.getElementById('blurRadius').addEventListener('input', e => {
  document.getElementById('blurRadiusVal').textContent = e.target.value;
  invalidateFilter(4);
  scheduleRender();
});
document.getElementById('blurType').addEventListener('change', () => { invalidateFilter(4); scheduleRender(); });
document.getElementById('reduceColors').addEventListener('input', e => {
  document.getElementById('reduceColorsVal').textContent = e.target.value;
  invalidateFilter(5);
  scheduleRender();
});
document.getElementById('btnResetView').addEventListener('click', () => { resetView(); renderAll(); });

// ---- Cursor management ----
// Custom cursor SVGs encoded as data URIs
const CURSOR_ZOOM_IN = (() => {
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <circle cx="10" cy="10" r="7" fill="none" stroke="white" stroke-width="2"/>
    <circle cx="10" cy="10" r="7" fill="none" stroke="black" stroke-width="1"/>
    <line x1="15.5" y1="15.5" x2="22" y2="22" stroke="white" stroke-width="3" stroke-linecap="round"/>
    <line x1="15.5" y1="15.5" x2="22" y2="22" stroke="black" stroke-width="1.5" stroke-linecap="round"/>
    <line x1="7" y1="10" x2="13" y2="10" stroke="black" stroke-width="1.5" stroke-linecap="round"/>
    <line x1="10" y1="7" x2="10" y2="13" stroke="black" stroke-width="1.5" stroke-linecap="round"/>
  </svg>`;
  return `url("data:image/svg+xml,${encodeURIComponent(svg)}") 10 10, zoom-in`;
})();

const CURSOR_ZOOM_OUT = (() => {
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <circle cx="10" cy="10" r="7" fill="none" stroke="white" stroke-width="2"/>
    <circle cx="10" cy="10" r="7" fill="none" stroke="black" stroke-width="1"/>
    <line x1="15.5" y1="15.5" x2="22" y2="22" stroke="white" stroke-width="3" stroke-linecap="round"/>
    <line x1="15.5" y1="15.5" x2="22" y2="22" stroke="black" stroke-width="1.5" stroke-linecap="round"/>
    <line x1="7" y1="10" x2="13" y2="10" stroke="black" stroke-width="1.5" stroke-linecap="round"/>
  </svg>`;
  return `url("data:image/svg+xml,${encodeURIComponent(svg)}") 10 10, zoom-out`;
})();

let spaceHeld = false;
let altHeld = false;

function getEffectiveTool() {
  if (spaceHeld) return 'pan';
  return currentTool;
}

function updateGridCursor() {
  const grid = document.getElementById('grid');
  const tool = getEffectiveTool();
  switch (tool) {
    case 'pan':  grid.style.cursor = isPanning ? 'grabbing' : 'grab'; break;
    case 'zoom': grid.style.cursor = altHeld ? CURSOR_ZOOM_OUT : CURSOR_ZOOM_IN; break;
    case 'line': grid.style.cursor = 'crosshair'; break;
    case 'free': grid.style.cursor = 'crosshair'; break;
    default:     grid.style.cursor = 'default';
  }
}

// ---- Keyboard state for Space (temp pan) and Alt (zoom-out) ----
document.addEventListener('keydown', e => {
  if (e.key === ' ' && !spaceHeld) {
    e.preventDefault();
    spaceHeld = true;
    updateGridCursor();
  }
  if (e.key === 'Alt') {
    altHeld = true;
    updateGridCursor();
  }
});
document.addEventListener('keyup', e => {
  if (e.key === ' ') {
    spaceHeld = false;
    updateGridCursor();
  }
  if (e.key === 'Alt') {
    altHeld = false;
    updateGridCursor();
  }
});
// Reset modifier state when window loses focus
window.addEventListener('blur', () => {
  spaceHeld = false;
  altHeld = false;
  updateGridCursor();
});

// Tool buttons
document.querySelectorAll('#toolbar button[data-tool]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#toolbar button[data-tool]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentTool = btn.dataset.tool;
    updateGridCursor();
  });
});

document.getElementById('btnUndo').addEventListener('click', () => {
  annotations.pop();
  renderAll();
});
document.getElementById('btnClearAnnot').addEventListener('click', () => {
  annotations = [];
  renderAll();
});

// ---- Pan / Zoom / Draw (synced across panels) ----
let isPanning = false;
let panStart = { x: 0, y: 0 };
let isZooming = false; // zoom tool drag state

function screenToImage(sx, sy, panelEl) {
  const rect = panelEl.getBoundingClientRect();
  const lx = sx - rect.left;
  const ly = sy - rect.top;
  return [(lx - view.x) / view.scale, (ly - view.y) / view.scale];
}

function applyZoom(clientX, clientY, panelEl, zoomIn) {
  const rect = panelEl.getBoundingClientRect();
  const mx = clientX - rect.left;
  const my = clientY - rect.top;
  const factor = zoomIn ? 1.5 : 1 / 1.5;
  const newScale = view.scale * factor;
  view.x = mx - (mx - view.x) * (newScale / view.scale);
  view.y = my - (my - view.y) * (newScale / view.scale);
  view.scale = newScale;
  renderAll();
}

for (let i = 0; i < PANEL_COUNT; i++) {
  const canvas = canvases[i];
  const panel = panels[i];

  canvas.addEventListener('pointerdown', e => {
    if (!srcImage) return;
    e.preventDefault();
    canvas.setPointerCapture(e.pointerId);

    const tool = getEffectiveTool();

    if (tool === 'pan') {
      isPanning = true;
      panStart = { x: e.clientX - view.x, y: e.clientY - view.y };
      updateGridCursor();
    } else if (tool === 'zoom') {
      // Click to zoom in/out instantly
      const zoomIn = !e.altKey;
      applyZoom(e.clientX, e.clientY, panel, zoomIn);
      isZooming = true;
    } else {
      const [ix, iy] = screenToImage(e.clientX, e.clientY, panel);
      const color = document.getElementById('annotColor').value;
      const width = parseInt(document.getElementById('annotWidth').value);
      drawState = { type: tool === 'line' ? 'line' : 'free', points: [[ix, iy]], color, width };
    }
  });

  canvas.addEventListener('pointermove', e => {
    if (!srcImage) return;
    if (isPanning) {
      view.x = e.clientX - panStart.x;
      view.y = e.clientY - panStart.y;
      renderView(); // fast: no filter recomputation
    } else if (drawState) {
      const [ix, iy] = screenToImage(e.clientX, e.clientY, panel);
      if (drawState.type === 'line') {
        drawState.points[1] = [ix, iy];
      } else {
        drawState.points.push([ix, iy]);
      }
      renderView(); // fast: no filter recomputation, shows live preview
    }
  });

  canvas.addEventListener('pointerup', e => {
    if (isPanning) {
      isPanning = false;
      updateGridCursor();
    } else if (isZooming) {
      isZooming = false;
    } else if (drawState) {
      const [ix, iy] = screenToImage(e.clientX, e.clientY, panel);
      if (drawState.type === 'line') {
        drawState.points[1] = [ix, iy];
      } else {
        drawState.points.push([ix, iy]);
      }
      if (drawState.points.length >= 2) annotations.push(drawState);
      drawState = null;
      renderView();
    }
  });

  canvas.addEventListener('wheel', e => {
    if (!srcImage) return;
    e.preventDefault();
    const rect = panel.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const factor = e.deltaY < 0 ? 1.1 : 1/1.1;
    const newScale = view.scale * factor;
    const oldMip = computeMipLevel();

    // Zoom toward mouse position
    view.x = mx - (mx - view.x) * (newScale / view.scale);
    view.y = my - (my - view.y) * (newScale / view.scale);
    view.scale = newScale;

    // Only recompute filters when crossing a mip level boundary
    if (computeMipLevel() !== oldMip) {
      renderAll();
    } else {
      renderView();
    }
  }, { passive: false });
}

// Set initial cursor
updateGridCursor();

// ---- Initial sizing ----
requestAnimationFrame(resizeCanvases);
</script>
</body>
</html>
